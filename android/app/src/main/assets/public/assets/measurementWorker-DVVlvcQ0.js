var m=Object.defineProperty;var w=(d,t,n)=>t in d?m(d,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):d[t]=n;var f=(d,t,n)=>w(d,typeof t!="symbol"?t+"":t,n);class C{constructor(){f(this,"cv");f(this,"isReady",!1);f(this,"processingQueue",[]);this.initializeOpenCV()}async initializeOpenCV(){try{importScripts("https://docs.opencv.org/4.8.0/opencv.js");const t=()=>{typeof cv<"u"&&cv.Mat?(this.cv=cv,this.isReady=!0,self.postMessage({type:"READY"}),console.log("OpenCV avanzado cargado correctamente en worker"),this.processingQueue.forEach(n=>this.processDetection(n)),this.processingQueue=[]):setTimeout(t,100)};setTimeout(t,100)}catch(t){console.error("Error cargando OpenCV:",t),self.postMessage({type:"ERROR",error:t.message})}}detectContoursAdvanced(t,n){if(!this.cv||!this.isReady)return[];const i=this.cv.matFromImageData(t),e=new this.cv.Mat,s=[];try{this.cv.cvtColor(i,e,this.cv.COLOR_RGBA2GRAY);const o=[{blur:3,canny1:30,canny2:90,morph:2},{blur:5,canny1:50,canny2:150,morph:3},{blur:7,canny1:80,canny2:200,morph:4}],r=[];for(const l of o){const a=this.processImageScale(e,l),u=this.findContoursRobust(a,n);r.push(...u),a.delete()}const c=this.mergeOverlappingContours(r),h=this.validateContours(c,t.width,t.height);s.push(...h),r.forEach(l=>{l&&l.delete&&l.delete()})}catch(o){console.error("Error en detección avanzada:",o)}finally{i.delete(),e.delete()}return s}processImageScale(t,n){const i=new this.cv.Mat,e=new this.cv.Mat,s=new this.cv.Mat;try{this.cv.GaussianBlur(t,i,new this.cv.Size(n.blur,n.blur),0),this.cv.Canny(i,e,n.canny1,n.canny2,3,!0);const o=this.cv.getStructuringElement(this.cv.MORPH_ELLIPSE,new this.cv.Size(n.morph,n.morph));return this.cv.morphologyEx(e,s,this.cv.MORPH_CLOSE,o),this.cv.morphologyEx(s,s,this.cv.MORPH_OPEN,o),o.delete(),i.delete(),e.delete(),s}catch(o){throw i.delete(),e.delete(),s.delete(),o}}findContoursRobust(t,n){const i=new this.cv.MatVector,e=new this.cv.Mat,s=[];try{this.cv.findContours(t,i,e,this.cv.RETR_EXTERNAL,this.cv.CHAIN_APPROX_SIMPLE);for(let o=0;o<i.size();o++){const r=i.get(o),c=this.cv.contourArea(r);if(c>=n){const h=new this.cv.Mat,l=.02*this.cv.arcLength(r,!0);this.cv.approxPolyDP(r,h,l,!0);const a=this.cv.boundingRect(h),u=this.cv.arcLength(r,!0),p=a.width/a.height,g=c/(a.width*a.height),v=c/this.cv.contourArea(this.cv.convexHull(r,new this.cv.Mat,!1));let y=this.calculateContourConfidence({area:c,perimeter:u,aspectRatio:p,extent:g,solidity:v,rect:a});y>.3&&s.push({x:a.x,y:a.y,width:a.width,height:a.height,area:c,confidence:y,contour:r.clone()}),h.delete()}r.delete()}}catch(o){console.error("Error encontrando contornos:",o)}finally{i.delete(),e.delete()}return s}calculateContourConfidence(t){const{area:n,perimeter:i,aspectRatio:e,extent:s,solidity:o,rect:r}=t;let c=.5;return e>.2&&e<5&&(c+=.2),s>.6&&(c+=.15),o>.8&&(c+=.1),n>2e3&&n<5e4&&(c+=.1),(r.width<20||r.height<20)&&(c-=.2),(r.width>800||r.height>800)&&(c-=.1),4*Math.PI*n/(i*i)>.3&&(c+=.1),Math.max(0,Math.min(1,c))}mergeOverlappingContours(t){if(t.length<=1)return t;const n=[],i=new Set;for(let e=0;e<t.length;e++){if(i.has(e))continue;const s=[t[e]];i.add(e);for(let o=e+1;o<t.length;o++)i.has(o)||this.isOverlapping(t[e],t[o],.3)&&(s.push(t[o]),i.add(o));if(s.length>1){const o=this.fuseContours(s);n.push(o)}else n.push(t[e])}return n}isOverlapping(t,n,i){const e=t,s=n,o=Math.max(e.x,s.x),r=Math.max(e.y,s.y),c=Math.min(e.x+e.width,s.x+s.width),h=Math.min(e.y+e.height,s.y+s.height);if(o>=c||r>=h)return!1;const l=(c-o)*(h-r),a=e.width*e.height,u=s.width*s.height,p=Math.min(a,u);return l/p>i}fuseContours(t){let n=1/0,i=1/0,e=-1/0,s=-1/0,o=0,r=0;for(const c of t)n=Math.min(n,c.x),i=Math.min(i,c.y),e=Math.max(e,c.x+c.width),s=Math.max(s,c.y+c.height),o+=c.area,r=Math.max(r,c.confidence);return{x:n,y:i,width:e-n,height:s-i,area:o,confidence:r*.9}}validateContours(t,n,i){return t.filter(e=>{const{x:s,y:o,width:r,height:c,area:h,confidence:l}=e,a=s>=5&&o>=5&&s+r<=n-5&&o+c<=i-5,u=r>=15&&c>=15&&r<=n*.8&&c<=i*.8,p=r/c>=.1&&r/c<=10,g=h>=r*c*.3,v=l>=.4;return a&&u&&p&&g&&v}).map(e=>({x:e.x,y:e.y,width:e.width,height:e.height,area:e.area,confidence:e.confidence})).sort((e,s)=>s.confidence-e.confidence)}processDetection(t){if(!this.isReady){this.processingQueue.push(t);return}try{const{imageData:n,minArea:i=1e3}=t;console.log("Procesando detección avanzada:",{imageSize:`${n.width}x${n.height}`,minArea:i});const e=this.detectContoursAdvanced(n,i);console.log("Detección completada:",{objectsFound:e.length,avgConfidence:e.length>0?(e.reduce((s,o)=>s+o.confidence,0)/e.length).toFixed(2):0}),self.postMessage({type:"DETECTED",rects:e.slice(0,3)})}catch(n){console.error("Error en procesamiento:",n),self.postMessage({type:"ERROR",error:n.message})}}}const x=new C;self.onmessage=function(d){const{type:t,...n}=d.data;switch(t){case"INIT":break;case"DETECT":x.processDetection(n);break;default:console.warn("Tipo de mensaje no reconocido:",t)}};
