let v=!1;function O(){return new Promise((c,t)=>{if(typeof self<"u"&&self.cv&&self.cv.Mat){v=!0,c();return}try{importScripts("https://docs.opencv.org/4.8.0/opencv.js");const e=()=>{typeof self<"u"&&self.cv&&self.cv.Mat?(v=!0,console.log("OpenCV loaded in worker"),c()):setTimeout(e,100)};setTimeout(e,100)}catch(e){console.error("Failed to load OpenCV in worker:",e),c()}})}function R(c){const t=[];for(let e=0;e<c.length;e++){let r=!1;for(let o=0;o<t.length;o++)if(T(c[e],t[o])>.5){r=!0,c[e].confidence&&t[o].confidence&&c[e].confidence>t[o].confidence&&(t[o]=c[e]);break}r||t.push(c[e])}return t}function T(c,t){const e=Math.max(c.x,t.x),r=Math.max(c.y,t.y),o=Math.min(c.x+c.width,t.x+t.width),l=Math.min(c.y+c.height,t.y+t.height);if(o<=e||l<=r)return 0;const f=(o-e)*(l-r),d=c.width*c.height,p=t.width*t.height,u=d+p-f;return f/u}function V(c,t){if(!v||!cv)return w(c,t);try{const e=cv.matFromImageData(c),r=new cv.Mat;cv.cvtColor(e,r,cv.COLOR_RGBA2GRAY);const o=new cv.Mat;cv.GaussianBlur(r,o,new cv.Size(9,9),0);const l=new cv.Mat;cv.Canny(o,l,80,200);const f=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(5,5));cv.morphologyEx(l,l,cv.MORPH_CLOSE,f),f.delete();const d=new cv.MatVector,p=new cv.Mat;cv.findContours(l,d,p,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);const u=[],i=c.width*c.height;for(let a=0;a<d.size();a++){const s=d.get(a),h=cv.boundingRect(s),y=cv.contourArea(s),m=cv.arcLength(s,!0),M=4*Math.PI*y/(m*m),x=h.width/h.height,A=h.width*h.height,C=y/A;y>=t*3&&y<=i*.3&&M>.2&&x>.3&&x<3&&C>.4&&h.width>30&&h.height>30&&u.push({x:h.x,y:h.y,width:h.width,height:h.height,area:y,confidence:Math.min(M*C*2,1)})}e.delete(),r.delete(),o.delete(),l.delete(),d.delete(),p.delete();const n=R(u);return n.sort((a,s)=>s.confidence*s.area-a.confidence*a.area),n.slice(0,2)}catch(e){return console.error("OpenCV detection error:",e),w(c,t)}}function w(c,t){const{width:e,height:r,data:o}=c,l=[],f=new Uint8Array(e*r);for(let i=1;i<r-1;i++)for(let n=1;n<e-1;n++){const a=(i*e+n)*4;(o[a]+o[a+1]+o[a+2])/3;const s=-1*g(o,n-1,i-1,e)+-2*g(o,n-1,i,e)+-1*g(o,n-1,i+1,e)+1*g(o,n+1,i-1,e)+2*g(o,n+1,i,e)+1*g(o,n+1,i+1,e),h=-1*g(o,n-1,i-1,e)+-2*g(o,n,i-1,e)+-1*g(o,n+1,i-1,e)+1*g(o,n-1,i+1,e)+2*g(o,n,i+1,e)+1*g(o,n+1,i+1,e),y=Math.sqrt(s*s+h*h);f[i*e+n]=y>80?255:0}const d=new Array(e*r).fill(!1),p=e*r;for(let i=0;i<r;i++)for(let n=0;n<e;n++){const a=i*e+n;if(f[a]>0&&!d[a]){const s=D(f,d,n,i,e,r),h=s.width*s.height;h>=t*2&&h<=p*.3&&s.width>20&&s.height>20&&s.width/s.height>.3&&s.width/s.height<3&&l.push({x:s.x,y:s.y,width:s.width,height:s.height,area:h,confidence:Math.min(h/(t*10),1)})}}const u=R(l);return u.sort((i,n)=>n.confidence*n.area-i.confidence*i.area),u.slice(0,2)}function g(c,t,e,r){const o=(e*r+t)*4;return(c[o]+c[o+1]+c[o+2])/3}function D(c,t,e,r,o,l){const f=[[e,r]];let d=e,p=e,u=r,i=r;for(;f.length>0;){const[n,a]=f.pop(),s=a*o+n;n<0||n>=o||a<0||a>=l||t[s]||c[s]===0||(t[s]=!0,d=Math.min(d,n),p=Math.max(p,n),u=Math.min(u,a),i=Math.max(i,a),f.push([n+1,a],[n-1,a],[n,a+1],[n,a-1]))}return{x:d,y:u,width:p-d+1,height:i-u+1}}let E=!1;self.onmessage=async c=>{const t=c.data;if(t.type==="INIT"){if(!E)try{await O(),E=!0}catch(e){console.error("Failed to initialize OpenCV:",e)}postMessage({type:"READY"});return}if(t.type==="DETECT")try{const e=v?V(t.imageData,t.minArea):w(t.imageData,t.minArea);postMessage({type:"DETECTED",rects:e})}catch(e){console.error("Worker error:",e);try{const r=w(t.imageData,t.minArea);postMessage({type:"DETECTED",rects:r})}catch(r){console.error("Native detection also failed:",r),postMessage({type:"DETECTED",rects:[]})}}};
